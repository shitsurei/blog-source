---
date: 2018-10-30 23:44:35
permalink: php3
title: PHP学习笔记3
tags: [数组,内存模型]
copyright: true
sticky: false
categories: PHP
---

PHP中的数组是一个非常有意思的数据结构，我们最常用的两种用于保存数据的结构是list和map，不论是链式存储还是顺序存储，不论是散列存储还是其他的二叉树存储，保存相同数据类型的集合与复杂数据类型内部结构的存储都是日常开发中最基本的需求。而在PHP中的数组可以看做是这两种数据结构的综合，弱类型语言的机制使得数组不再是单一数据类型的集合，我们既可以把数组当成一个map，用于保存键值对，又可以作为list保存同类型元素。
其次，PHP是基于C语言编写的面向对象脚本语言，他的内存模型也类似于C，分为堆、栈、常量区等几个部分，在今后的面向对象学习中还需要更深的理解。

<!-- more -->

## 数组

### 数组创建

PHP的数组支持动态增长，跳跃赋值

```php
#PHP中的数组使用array()函数创建
$value=1;
$arrayName = array('index' => $value, );
```

### 数组分类

* 索引数组

带有数字索引的数组，可采用自动分配(索引从0开始)或手动分配(不重复即可,重复时以后分配的为准)

* 关联数组

带有指定键的数组，任意分配给数组的指定键的数组，可在创建数组时直接分配或之后的赋值中再分配

```php
$arr1 = array('a' => 1,'b' => 2);
$arr1['c']=3;
var_dump($arr1);//array(6) { ["a"]=> int(1) ["b"]=> int(2) ["c"]=> int(3) }
```
> 缺省键值分配原则
> * 从首个元素遍历至当前元素，寻找是否有以数字作为键值的元素
>  * 如果没有，以0作为默认的缺省键值
>  * 如果有，将距离缺省元素最近的前一位符合1条件的元素的键值加1作为缺省元素的键值
> * 如果之后的元素占用了当且缺省元素所分配的键值，遵循重复覆盖的原则

```php
$arr2 = array('3' => 1,'8' => 2,'a' => 3,4,'c' => 5);
var_dump($arr2);//array(6) { [3]=> int(1) [8]=> int(2) ["a"]=> int(3) [9]=> int(4) ["c"]=> int(5) }
```

> 非正常值作为键名
> 1. 使用true作为键名即使用1为键名，使用false作为键名即使用0作为键名
> 2. 使用小数作为键名时，自动截断小数部分

* 多维数组

包含一个或多个数组的数组

### 数组函数

* 获得数组的长度

```php
$arr2_len=count($arr2);
echo $arr2_len;//5
```

* 判断数据类型是否为数组

```php
echo "is_array".is_array($arr2);//1
```

* 删除数组的任意个键值，但不会重建索引

```php
$arr3 = array('a','b','c','d');
unset($arr3[0],$arr3[1]);
print_r($arr3);//Array ( [2] => c [3] => d ) 
```

* 遍历数组

```php
foreach ($arr1 as $key => $value) {
	echo "$key=$value";//a=1b=2c=3
}
#for循环只能用于遍历索引数组
for ($i=0; $i < $arr2_len; $i++) { 
	echo "$arr2[$i]";//遍历关联数组输出报错
}
```

* 数组排序

 * 索引数组
	 * sort() - 以升序对数组排序
	 * rsort() - 以降序对数组排序
 * 关联数组
	 * asort() - 根据值，以升序对关联数组进行排序
	 * ksort() - 根据键，以升序对关联数组进行排序
	 * arsort() - 根据值，以降序对关联数组进行排序
	 * krsort() - 根据键，以降序对关联数组进行排序
 * 冒泡排序 - bubbleSort();
 * 选择排序 - selectSort();
 * 插入排序 - insertSort();


### 二维数组

* 定义

```php
#可采用直接定义或单个元素定义，每一行数组个数可以不同
$arr4 = array(
array('1','2','3','4','5'),
array('11','21','25'),
array('1','2','3','4','5'),
array('10')
);
#等价于
$arr4[0] = array('1','2','3','4','5');
$arr4[1] = array('11','21','25');
$arr4[2] = array('1','2','3','4','5');
$arr4[3] = array('10');
```

* 遍历二维数组

```php
for ($i=0; $i < count($arr4); $i++) { 
	for ($j=0; $j < count($arr4[$i]); $j++) { 
		echo $arr4[$i][$j]."&nbsp;";
	}
	echo "<br/>";
}
/*输出
1 2 3 4 5 
11 21 25 
1 2 3 4 5 
10
*/
```


## PHP内存模型

### 栈区：存放基本数据类型

```php
#a和b都是存放在栈区不同地址空间的变量，其保存的值都为int型整数，a赋值给b时将0这一值赋给b的内存空间，因此对b的操作不会影响a的值
$a=0;
$b=$a;
$b++;
echo "$a/$b";//0/1
#当把a的地址赋给b之后，b的内存空间存放的即为a的地址，对b的操作实际上是对a地址的操作，即对a的值的操作
$b=&$a;
$b++;
echo "$a/$b";//1/1
```

### 堆区：存放对象

```php
class Person
{
	public $name;
	public $age;
}
#p1变量存放在栈中，p1对象存放在堆中
$p1=new Person;
#p1通过地址引用访问堆中对象的成员变量
$p1->name="Jack";
$p1->age=20;
#调用函数时，栈区会开辟一片新栈，存放p变量，p和p1分别位于栈区不同的地址空间，但是其中保存的值相同，都指向堆中p1对象
function change_name($p)
{
	$p->name="Tom";
}
echo "$p1->name";//Jack
change_name($p1);
echo "$p1->name";//Tom
```

### 全局区（静态数据区）
* 存放global关键字修饰的全局变量，全局变量在所有的栈中都可以访问
* 存放static关键字修饰的成员变量，一次创建，不随着对象的销毁而销毁

### 常量区：存放常量
* 存放常量，const关键字修饰的常量，声明时就要赋初值
### 代码区：存放指令

<hr />
